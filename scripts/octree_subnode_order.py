
# standard imports
import sys


#
# This function compute the sub-node id with the given ray direction id and
# access id
#
def direction_access_at_i(direction_id, access_id):
    assert isinstance(direction_id,int)
    assert direction_id >= 0
    assert direction_id < 8
    assert isinstance(access_id,int)
    assert access_id >= 0
    assert access_id < 8

    return 0x7 & (access_id ^ (~direction_id))

#
# This function computes for an octree node, the sub-nodes access list depending
# the direction of ray
#
def direction_access_lists(bitfield):
    print '/*'
    print ' * This array is the sub-node access order depending on the ray direction.'
    print ' *'
    print ' * Generated by: python octree_subnode_order.py --direction-access-lists'
    print ' *'
    print ' *  uint32_t nodeSubnodeAccessList ='
    print ' *      kOctreeDirectionAccessLists[rayDirectionId];'
    print ' */'
    print 'uint32_t const kOctreeDirectionAccessLists[8] = {'

    for direction_id in range(8):
        mask = 0

        for access_id in range(8):
            subnodeId = direction_access_at_i(direction_id, access_id)

            if not bitfield:
                print '{},'.format(subnodeId),

            mask = mask | (subnodeId << (access_id * 4))

        if bitfield:
            print '    0x{:08x},'.format(mask)

        else:
            print ''

    print '};'

#
# This function computes the subnode access lists depending on the node's
# subnodes mask and ray direction
#
def subnode_access_lists():
    print '/*'
    print ' * This array is the node\'s sub-node access list depending on the'
    print ' * ray\'s direction and the node\'s sub-nodes mask.'
    print ' *'
    print ' * Generated by: python octree_subnode_order.py --subnode-access-lists'
    print ' *'
    print ' *  uint32_t nodeSubnodeAccessList ='
    print ' *      kOctreeSubnodeMaskAccessLists[rayDirectionId * 256 + nodeSubnodeMask];'
    print ' */'
    print 'uint32_t const kOctreeSubnodeMaskAccessLists[256 * 8] = {'

    for direction_id in range(8):
        print '    // ray direction {}'.format(direction_id)

        i = 0

        for subnodes_mask in range(256):
            access_list = 0
            subnodes_count = 0

            for access_id in range(8):
                subnode_id = direction_access_at_i(direction_id, access_id)

                if ((1 << subnode_id) & subnodes_mask) == 0:
                    # according the node's subnode mask, there is no sub-node <subnode_id>
                    continue

                access_list = access_list | (subnode_id << (subnodes_count * 4))
                subnodes_count += 1

            i += 1

            if i == 1:
                print ' ' * 3,

            print '0x{:08x},'.format(
                access_list
            ),

            if i == 8:
                print ''
                i = 0

    print '};'


if __name__ == '__main__':
    assert len(sys.argv) == 2

    if sys.argv[1] == '--direction-access-lists':
        direction_access_lists(True)

    elif sys.argv[1] == '--subnode-access-lists':
        subnode_access_lists()

    else:
        assert False
